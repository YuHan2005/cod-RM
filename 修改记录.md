# 开发日志


## 2025-09-23

**变更**

1. **灯条特征计算调整（types.hpp）**
   - `Light` 类：
     ```cpp
     // length = cv::norm(top - bottom);
     // width  = cv::norm(p[0] - p[1]);
     // 长宽直接用 RotatedRect 的 size，更稳定
     length = std::max(this->size.width, this->size.height);
     width  = std::min(this->size.width, this->size.height);
     ```
     ➜ 改为直接使用 `RotatedRect::size` 的长短边，减少噪声和数值抖动。

   - `Light2` 类：
     ```cpp
     // length = cv::norm(top - bottom);
     // width  = area / length;
     // center = (top + bottom) / 2;

     length = cv::norm(top - bottom);
     width  = (length > 0.0)
                  ? static_cast<double>(area) / length
                  : 0.0;
     center = (top + bottom) * 0.5f;
     ```
     ➜ 保留基于几何关系的长宽计算，引入 `length > 0` 判定，避免除零；同时明确 `center` 为上下端点中点。

2. **灯条拟合逻辑优化（armor_detector.cpp）**
   - 新逻辑（基于 `vx, vy`，对竖直/非竖直灯条分别处理）：
     ```cpp
     float vx = return_param[0];
     float vy = return_param[1];
     const float eps = 1e-3f;

     if (std::fabs(vx) < eps) {
       // 竖直灯条，直接用竖直
       top    = cv::Point2f(b_rect.x + b_rect.width * 0.5f, b_rect.y);
       bottom = cv::Point2f(b_rect.x + b_rect.width * 0.5f, b_rect.y + b_rect.height);
       angle_k = 0.0;  // 或者 90，看定义
     } else {
       float k = vy / vx;
       auto b = (return_param[3] + b_rect.y) - k * (return_param[2] + b_rect.x);
       top    = cv::Point2f((b_rect.y - b) / k, b_rect.y);
       bottom = cv::Point2f((b_rect.y + b_rect.height - b) / k, b_rect.y + b_rect.height);
       angle_k = std::atan(k) / CV_PI * 180 - 90;
       if (angle_k > 90) {
         angle_k = 180 - angle_k;
       }
     }
     ```
   - 替换旧逻辑：
     ```cpp
     /*
     if (int(return_param[0] * 100) == 100 || int(return_param[1] * 100) == 0) {
       top = cv::Point2f(b_rect.x + b_rect.width / 2, b_rect.y);
       bottom = cv::Point2f(b_rect.x + b_rect.width / 2, b_rect.y + b_rect.height);
       angle_k = 0;
     } else {
       auto k = return_param[1] / return_param[0];
       auto b = (return_param[3] + b_rect.y) - k * (return_param[2] + b_rect.x);
       top = cv::Point2f((b_rect.y - b) / k, b_rect.y);
       bottom = cv::Point2f((b_rect.y + b_rect.height - b) / k, b_rect.y + b_rect.height);
       angle_k = std::atan(k) / CV_PI * 180 - 90;
       if (angle_k > 90) {
         angle_k = 180 - angle_k;
       }
     }
     */
     ```
   ➜ 通过 `vx` 的绝对值判断是否“近似竖直”，逻辑更直观、数值更稳定。

3. **对称轴求解加速（LightCornerCorrector::findSymmetryAxis）**
   - 重写 `LightCornerCorrector::findSymmetryAxis`，以**牺牲部分精度**为代价，降低计算复杂度，加快运行速度（具体实现细节待补充和实测评估）。

4. **数字图像发布优化（ArmorDetectorNode::detectArmors）**
   - 原实现（多一次拷贝）：
     ```cpp
     /*
     if (!armors.empty()) {
       auto all_num_img = detector_->getAllNumbersImage();
       number_img_pub_.publish(
         *cv_bridge::CvImage(img_msg->header, "mono8", all_num_img).toImageMsg());
     }
     */
     ```
   - 新实现（减少拷贝，直接发布 SharedPtr）：
     ```cpp
     if (!armors.empty()) {
       auto all_num_img = detector_->getAllNumbersImage();
       auto msg = cv_bridge::CvImage(img_msg->header, "mono8", all_num_img).toImageMsg();
       number_img_pub_.publish(msg);   // 直接传 SharedPtr
     }
     ```
   ➜ 降低一次多余的拷贝/临时对象创建。

5. **PnP 多解筛选策略重写（ArmorDetectorNode::PnPSolutionsSelection）**
   - 函数 `void ArmorDetectorNode::PnPSolutionsSelection(...)` 逻辑重写：
     - 引入「先验（预测）姿态」 + 「重投影误差」联合决策；
     - 由单纯依赖重投影，改为“先验与重投影共同主导”的筛选策略，以提升在噪声/歧义场景下的稳定性。  
   ➜ 具体实现依赖 EKF/预测模块，后续需要配合实战数据验证。

6. **BA 求解器重写（BaSolver::solveBa）**
   - `bool BaSolver::solveBa(...)` 函数整体重写（主要基于 AI 提供版本），核心设计：
     - 保留 g2o + Sophus + 内参 K 的投影模型；
     - 将 **多帧窗口 BA** 引入，自适应处理当前队列内的装甲板观测；
     - 仅优化旋转（或 yaw）等少量关键自由度，保证实时性。
   - 新版本待长期实测验证数值稳定性与鲁棒性。

7. **use_ba_ 为真时的逻辑重构（配合新的 BaSolver）**
   - 当 `use_ba_ == true` 时：
     - 若当前装甲板为**离图像中心最近的目标**（`armor.Close_Center == true`）：
       - 使用长度为 **5** 的 `tracked_armors_main_` 队列进行多帧 BA 优化；
       - 仅在编号相同且中心漂移不大的条件下累积窗口，否则清空重建。
     - 其他装甲板：
       - 临时创建长度为 **1** 的队列，调用 `solveBa` 做**单帧 BA** 轻量优化。
   ➜ 实现了「主目标多帧平滑、其他目标轻量修正」的分级策略，更贴合实战自瞄需求。

**状态**
- 上述改动已编译通过，但整体行为仍处于「**待检验**」阶段，后续需要：
  - 联合 EKF/预测模块进行实战录制与回放分析；
  - 对比 `use_ba_` 开/关情况下的抖动、延迟与命中率变化。



## 2025/11/22


ArmorSolverNode::ArmorSolverNode
//double q_z_z = pow(t, 4) / 4 * x, q_z_vz = pow(t, 3) / 2 * x, q_vz_vz = pow(t, 2) * z;
    //double q_yaw_yaw = pow(t, 4) / 4 * yaw, q_yaw_vyaw = pow(t, 3) / 2 * x,
           //q_vyaw_vyaw = pow(t, 2) * yaw;
    //这里把对应的方向对应上
    double q_z_z = pow(t, 4) / 4 * z, q_z_vz = pow(t, 3) / 2 * z, q_vz_vz = pow(t, 2) * z;
    double q_yaw_yaw = pow(t, 4) / 4 * yaw, q_yaw_vyaw = pow(t, 3) / 2 * yaw,
           q_vyaw_vyaw = pow(t, 2) * yaw;


void Tracker::update修改了部分逻辑，用于配合NIS的门控制，减少重复运算


Eigen::MatrixXd ExtendedKalmanFilter::update修改了EKF更新算法，添加了NIS门控制，引入了新的参数nis_threshold_
  nis_th = 5.99;  break;  // χ²(2, 0.95)
  nis_th = 7.81;  break;  // χ²(3, 0.95)
   nis_th = 9.49;  break;  // χ²(4, 0.95)
   当观测维度为4的几个可能的值（理论上）
如果你想“严格一点”，可以选择 90%（7.78）；
“宽松一点”就用 99%（13.28）。

工程上的话，我们需要观测NIS曲线
看统计：
nis_fail_count_ / total_updates_ → 总体拒绝比例；

recent_nis_fail_ → 最近 N 帧的拒绝比例。

经验上比较舒服的区间：

拒绝比例在 1%~10% 之间通常还行；

基本不拒绝（≈0%）：阈值太大或 R 过大（EKF 太信观测）；

大半都被拒：阈值太小，或者 R 太小 / 模型差得离谱。




rm_interfaces::msg::GimbalCmd Solver::solve

 if (controller_delay_ != 0) {
        /*
        target_position.x() += controller_delay_ * target.velocity.x;
        target_position.y() += controller_delay_ * target.velocity.y;
        target_position.z() += controller_delay_ * target.velocity.z;
        target_yaw += controller_delay_ * target.v_yaw;
        armor_positions = getArmorPositions(target_position,
                                            target_yaw,
                                            target.radius_1,
                                            target.radius_2,
                                            target.dz,
                                            target.armors_num);
        chosen_armor_position = armor_positions.at(idx);
        if (chosen_armor_position.norm() < 0.1) {
          throw std::runtime_error("No valid armor to shoot");
        }
        calcYawAndPitch(chosen_armor_position, rpy, yaw, pitch);*/
        //尝试不再重新计算装甲板位置，直接补偿角度
        yaw += controller_delay_ * target.v_yaw;

      }修改了这一部分的逻辑

