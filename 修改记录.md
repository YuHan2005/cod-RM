# 开发日志

## 2025-09-24

**变更**
- 引入「同济版」扩展卡尔曼滤波（EKF）代码。
- 更换协方差更新为 **Joseph 形式**：  
  \[
  P = (I - K H)\,P\,(I - K H)^T + K R K^T
  \]
- 新增/调整卡方检验（NIS/NEES）统计字段与滑动窗口统计。

**备注（有待考证）**
> **有待考证**：GPT 评审指出当前卡方检验的实现不符合标准 EKF 门控（NIS 应使用先验状态与先验协方差，在**更新前**完成门控）。需对照后续代码与调用流程进一步核实。

**待核实清单**
- [ ] NIS 是否基于先验计算：`y = z - h(x_prior)`，`S = H P_prior H^T + R`，并在状态更新**前**做门控。
- [ ] 是否避免显式求逆：用 `LDLT/LLT` 的 `solve` 替代 `S.inverse()`。
- [ ] 量测残差字段访问是否越界（`residual[0..3]` 在量测维度 < 4 时会越界）。
- [ ] 每次更新开始是否重置 `nis_fail / nees_fail` 标志位。
- [ ] `P` 数值对称性修正：`P = 0.5 * (P + P^T)`（必要时）。

**相关文件**
- `New_Extended_Kalman_Filter.hpp`
- `New_Extended_Kalman_Filter.cpp`

---

## 2025-09-23

**变更**

1. **灯条特征计算调整（types.hpp）**
   - `Light` 类：
     ```cpp
     // length = cv::norm(top - bottom);
     // width  = cv::norm(p[0] - p[1]);
     // 长宽直接用 RotatedRect 的 size，更稳定
     length = std::max(this->size.width, this->size.height);
     width  = std::min(this->size.width, this->size.height);
     ```
     ➜ 改为直接使用 `RotatedRect::size` 的长短边，减少噪声和数值抖动。

   - `Light2` 类：
     ```cpp
     // length = cv::norm(top - bottom);
     // width  = area / length;
     // center = (top + bottom) / 2;

     length = cv::norm(top - bottom);
     width  = (length > 0.0)
                  ? static_cast<double>(area) / length
                  : 0.0;
     center = (top + bottom) * 0.5f;
     ```
     ➜ 保留基于几何关系的长宽计算，引入 `length > 0` 判定，避免除零；同时明确 `center` 为上下端点中点。

2. **灯条拟合逻辑优化（armor_detector.cpp）**
   - 新逻辑（基于 `vx, vy`，对竖直/非竖直灯条分别处理）：
     ```cpp
     float vx = return_param[0];
     float vy = return_param[1];
     const float eps = 1e-3f;

     if (std::fabs(vx) < eps) {
       // 竖直灯条，直接用竖直
       top    = cv::Point2f(b_rect.x + b_rect.width * 0.5f, b_rect.y);
       bottom = cv::Point2f(b_rect.x + b_rect.width * 0.5f, b_rect.y + b_rect.height);
       angle_k = 0.0;  // 或者 90，看定义
     } else {
       float k = vy / vx;
       auto b = (return_param[3] + b_rect.y) - k * (return_param[2] + b_rect.x);
       top    = cv::Point2f((b_rect.y - b) / k, b_rect.y);
       bottom = cv::Point2f((b_rect.y + b_rect.height - b) / k, b_rect.y + b_rect.height);
       angle_k = std::atan(k) / CV_PI * 180 - 90;
       if (angle_k > 90) {
         angle_k = 180 - angle_k;
       }
     }
     ```
   - 替换旧逻辑：
     ```cpp
     /*
     if (int(return_param[0] * 100) == 100 || int(return_param[1] * 100) == 0) {
       top = cv::Point2f(b_rect.x + b_rect.width / 2, b_rect.y);
       bottom = cv::Point2f(b_rect.x + b_rect.width / 2, b_rect.y + b_rect.height);
       angle_k = 0;
     } else {
       auto k = return_param[1] / return_param[0];
       auto b = (return_param[3] + b_rect.y) - k * (return_param[2] + b_rect.x);
       top = cv::Point2f((b_rect.y - b) / k, b_rect.y);
       bottom = cv::Point2f((b_rect.y + b_rect.height - b) / k, b_rect.y + b_rect.height);
       angle_k = std::atan(k) / CV_PI * 180 - 90;
       if (angle_k > 90) {
         angle_k = 180 - angle_k;
       }
     }
     */
     ```
   ➜ 通过 `vx` 的绝对值判断是否“近似竖直”，逻辑更直观、数值更稳定。

3. **对称轴求解加速（LightCornerCorrector::findSymmetryAxis）**
   - 重写 `LightCornerCorrector::findSymmetryAxis`，以**牺牲部分精度**为代价，降低计算复杂度，加快运行速度（具体实现细节待补充和实测评估）。

4. **数字图像发布优化（ArmorDetectorNode::detectArmors）**
   - 原实现（多一次拷贝）：
     ```cpp
     /*
     if (!armors.empty()) {
       auto all_num_img = detector_->getAllNumbersImage();
       number_img_pub_.publish(
         *cv_bridge::CvImage(img_msg->header, "mono8", all_num_img).toImageMsg());
     }
     */
     ```
   - 新实现（减少拷贝，直接发布 SharedPtr）：
     ```cpp
     if (!armors.empty()) {
       auto all_num_img = detector_->getAllNumbersImage();
       auto msg = cv_bridge::CvImage(img_msg->header, "mono8", all_num_img).toImageMsg();
       number_img_pub_.publish(msg);   // 直接传 SharedPtr
     }
     ```
   ➜ 降低一次多余的拷贝/临时对象创建。

5. **PnP 多解筛选策略重写（ArmorDetectorNode::PnPSolutionsSelection）**
   - 函数 `void ArmorDetectorNode::PnPSolutionsSelection(...)` 逻辑重写：
     - 引入「先验（预测）姿态」 + 「重投影误差」联合决策；
     - 由单纯依赖重投影，改为“先验与重投影共同主导”的筛选策略，以提升在噪声/歧义场景下的稳定性。  
   ➜ 具体实现依赖 EKF/预测模块，后续需要配合实战数据验证。

6. **BA 求解器重写（BaSolver::solveBa）**
   - `bool BaSolver::solveBa(...)` 函数整体重写（主要基于 AI 提供版本），核心设计：
     - 保留 g2o + Sophus + 内参 K 的投影模型；
     - 将 **多帧窗口 BA** 引入，自适应处理当前队列内的装甲板观测；
     - 仅优化旋转（或 yaw）等少量关键自由度，保证实时性。
   - 新版本待长期实测验证数值稳定性与鲁棒性。

7. **use_ba_ 为真时的逻辑重构（配合新的 BaSolver）**
   - 当 `use_ba_ == true` 时：
     - 若当前装甲板为**离图像中心最近的目标**（`armor.Close_Center == true`）：
       - 使用长度为 **5** 的 `tracked_armors_main_` 队列进行多帧 BA 优化；
       - 仅在编号相同且中心漂移不大的条件下累积窗口，否则清空重建。
     - 其他装甲板：
       - 临时创建长度为 **1** 的队列，调用 `solveBa` 做**单帧 BA** 轻量优化。
   ➜ 实现了「主目标多帧平滑、其他目标轻量修正」的分级策略，更贴合实战自瞄需求。

**状态**
- 上述改动已编译通过，但整体行为仍处于「**待检验**」阶段，后续需要：
  - 联合 EKF/预测模块进行实战录制与回放分析；
  - 对比 `use_ba_` 开/关情况下的抖动、延迟与命中率变化。
